import{_ as o,c as t,o as a,ae as i}from"./chunks/framework.iBmvQ__U.js";const u=JSON.parse('{"title":"Why scalux on Top of Redux Toolkit?","description":"","frontmatter":{},"headers":[],"relativePath":"en/faq.md","filePath":"en/faq.md"}'),s={name:"en/faq.md"};function n(c,e,l,r,d,h){return a(),t("div",null,e[0]||(e[0]=[i('<h1 id="why-scalux-on-top-of-redux-toolkit" tabindex="-1">Why <code>scalux</code> on Top of Redux Toolkit? <a class="header-anchor" href="#why-scalux-on-top-of-redux-toolkit" aria-label="Permalink to &quot;Why `scalux` on Top of Redux Toolkit?&quot;">​</a></h1><p>Redux Toolkit (RTK) is a major step forward for Redux developers, dramatically reducing boilerplate and baking in best practices by default. <code>scalux</code> actually builds on RTK and shares the same simplification philosophy. So, why consider <code>scalux</code>?</p><p><code>scalux</code> is, of course, <em>batteries‑included</em> with a set of built‑in features: history, finite‑state machines, the business API, labels and icons, helper components—all wrapped in a unified approach. Automatic generation of action types by the component with a semantic naming scheme is another <em>nice to have</em>.</p><p>Yet the motivation for creating <code>scalux</code> is <strong>not</strong> merely to be a feature bundle: a handful of plugins or utilities for vanilla RTK would have sufficed for that.</p><p>One of the driving forces behind <code>scalux</code> is to provide answers to certain architectural challenges that can remain even with RTK—especially when you need to handle <strong>complex operations that touch multiple slices of state</strong>, often coupled with <strong>asynchronous logic</strong> (such as API calls).</p><h2 id="the-challenge-of-multi‐slice-updates-in-rtk" tabindex="-1">The Challenge of Multi‑Slice Updates in RTK <a class="header-anchor" href="#the-challenge-of-multi‐slice-updates-in-rtk" aria-label="Permalink to &quot;The Challenge of Multi‑Slice Updates in RTK&quot;">​</a></h2><p>In a Redux application structured with slices (created via <code>createSlice</code>), a business operation may need to update state residing in several distinct slices. When asynchronous logic is involved, the standard pattern in RTK usually looks like this:</p><ol><li>Use <code>createAsyncThunk</code> to wrap the async call and dispatch actions that represent its life‑cycle (<code>pending</code>, <code>fulfilled</code>, <code>rejected</code>).</li><li>Implement <code>extraReducers</code> in <em>each</em> affected slice so it can listen for those actions and apply slice‑specific state changes.</li></ol><p>While this works, it can lead to the complete logic of a single business operation (API call <strong>plus</strong> updating slices A, B and C) being <strong>scattered</strong> across the thunk definition and multiple slice files. Understanding and maintaining the whole operation can require jumping back and forth between those files.</p><h2 id="the-scalux-approach-co‐locating-complex-logic" tabindex="-1">The <code>scalux</code> Approach: Co‑Locating Complex Logic <a class="header-anchor" href="#the-scalux-approach-co‐locating-complex-logic" aria-label="Permalink to &quot;The `scalux` Approach: Co‑Locating Complex Logic&quot;">​</a></h2><p><code>scalux</code> introduces patterns—like the <code>resolve</code> / <code>reducers</code> approach inside the <code>Updater</code> constructor (see the section <em>State Modifications: Updater</em> or equivalent)—specifically designed to tackle this scenario:</p><ol><li>The <code>resolve</code> function lets you handle asynchronous logic (e.g., an API fetch) and pre‑process whatever data the state update needs.</li><li>The <code>reducers</code> object allows you to define, <strong>in the same place</strong>, how every concerned part of the state (<code>InternalState</code>, often composed of slices) should change based on the result of <code>resolve</code>.</li></ol><h2 id="benefits-of-this-approach" tabindex="-1">Benefits of This Approach <a class="header-anchor" href="#benefits-of-this-approach" aria-label="Permalink to &quot;Benefits of This Approach&quot;">​</a></h2><p>By gathering asynchronous logic and multi‑slice state updates inside a <strong>single conceptual unit</strong> (<code>Updater</code>), <code>scalux</code> aims to:</p><ul><li><strong>Improve Readability:</strong> The entire logic of a complex business operation is visible and understandable in one spot.</li><li><strong>Simplify Maintenance:</strong> Changes tied to a specific operation are localized, reducing the chance of omissions or inconsistencies.</li><li><strong>Strengthen Consistency:</strong> Business intent is expressed more clearly in the code.</li></ul><hr><p>In short, while Redux Toolkit provides an excellent foundation for simplifying Redux, <code>scalux</code> goes a step further by offering dedicated tools for better structuring and co‑locating complex business logic—addressing specific architectural challenges faced when building Redux applications at larger scale.</p>',17)]))}const f=o(s,[["render",n]]);export{u as __pageData,f as default};
